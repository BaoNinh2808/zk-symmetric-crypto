/**
 * Supported encryption algorithms
 */
export type EncryptionAlgorithm = 'aes-256-ctr' | 'aes-128-ctr' | 'chacha20';

/**
 * The Array type used in the circuit
 * It's a Uint32Array, as all ChaCha20 operations are done on 32-bit words
 */
export type UintArray = Uint32Array;

/**
 * Represents a zero-knowledge proof
 */
export type Proof = {
    algorithm: EncryptionAlgorithm;
    /** Serialised SnarkJS proof */
    proofJson: string;
    /** The plaintext obtained as an output of the ZK circuit */
    plaintext: Uint8Array;
};

/**
 * Represents input for ZK operations
 * Can be either Uint8Array for file data loaded into memory
 * or string, which is the path to load said file
 */
type ZKInput = Uint8Array | string;

/**
 * Represents a verification key for ZK proofs
 */
export type VerificationKey = {
    /** Binary data for .zkey file */
    data: ZKInput;
    json?: any;
};

export type CircuitWasm = Uint8Array | string;

/**
 * Options for generating a proof
 */
export type GenerateProofOpts = {
    /** The algorithm to use for the encryption circuit */
    algorithm: EncryptionAlgorithm;
    /** Private input to the circuit (includes the key, iv, and counter) */
    privateInput: PrivateInput;
    /** Public input to the circuit (i.e., the ciphertext to decrypt) */
    publicInput: PublicInput;
    /** Operator to use for proving the circuit */
    operator: ZKOperator;
    logger?: Logger;
};

/**
 * Options for verifying a proof
 */
export type VerifyProofOpts = {
    /** JSON proof generated by "generateProof" function */
    proof: Proof;
    publicInput: PublicInput;
    operator: ZKOperator;
    logger?: Logger;
};

type ZKProof = { [key: string]: any } | string;

type ZKProofOutput = {
    proof: ZKProof;
    publicSignals: number[];
};

type ZKInputItem = number[] | number[][];

export type ZKProofInput = {
    key: ZKInputItem;
    nonce: ZKInputItem;
    counter: ZKInputItem;
    in: ZKInputItem;
};

/**
 * The operator to use for proving and verifying the groth16
 * proof of the ChaCha20 circuit
 * 
 * This generic interface allows for different implementations
 */
export type ZKOperator = {
    generateWitness(input: ZKProofInput, logger?: Logger): Promise<Uint8Array>;
    groth16Prove(witness: Uint8Array, logger?: Logger): Promise<ZKProofOutput>;
    groth16Verify(publicSignals: number[], proof: ZKProof, logger?: Logger): Promise<boolean>;
    /**
     * Release any used resources. The operator
     * should still be usable after this call.
     *
     * This is useful for releasing any resources
     * in case ZK operations are not going to be
     * used for a while.
     */
    release?(): void;
};

export type ZKParams = {
    getZkey: () => Promise<VerificationKey> | VerificationKey;
    getCircuitWasm: () => Promise<CircuitWasm> | CircuitWasm;
};

/**
 * Represents the private input for encryption
 */
export type PrivateInput = {
    /** 256 bit ChaCha20 key to decrypt ciphertext */
    key: Uint8Array;
    /** 192 bit IV for the ciphertext decryption */
    iv: Uint8Array;
    /**
     * Decryption offset in chunks
     * Specify 0 for the first chunk
     * @default 0
     */
    offset: number;
};

/**
 * Represents the public input for encryption
 */
export type PublicInput = {
    /** The ciphertext to decrypt */
    ciphertext: Uint8Array;
};

/**
 * Logger type for consistent logging across the application
 */
export type Logger = Pick<typeof console, 'info' | 'trace' | 'debug' | 'error' | 'warn'>;
