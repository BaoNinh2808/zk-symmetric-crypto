import { PrivateInput, Proof, PublicInput, UintArray, ZKOperator } from "./types"
import { makeUintArray, padArray, padU8ToU32Array, toUintArray } from "./utils"

// chunk size of data that is input to the ZK circuit
// in 32-bit words
export const ZK_CIRCUIT_CHUNK_SIZE = 16
// key size in bytes
export const KEY_SIZE_BYTES = 32
// iv size in bytes
export const IV_SIZE_BYTES = 12

/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 * 
 * @param privateInput private input to the circuit
 * will include the key, iv, and counter 
 * @param pub public input to the circuit,
 * will include the ciphertext and redacted plaintext
 * @param zkParams ZK params -- verification key and circuit wasm
 */
export async function generateProof(
	{
		key,
		iv,
		startCounter,
	}: PrivateInput,
	{ ciphertext }: PublicInput,
	operator: ZKOperator
): Promise<Proof> {
	if(key.length !== KEY_SIZE_BYTES) {
		throw new Error(`key must be ${KEY_SIZE_BYTES} bytes`)
	}
	if(iv.length !== IV_SIZE_BYTES) {
		throw new Error(`iv must be ${IV_SIZE_BYTES} bytes`)
	}

	const ciphertextArray = normaliseCiphertextForZk(
		ciphertext,
	)
	const keyU32 = toUintArray(key)
	const nonce = toUintArray(iv)

	const { proof, publicSignals } = await operator.groth16FullProve(
		{
			key: Array.from(keyU32),
			nonce: Array.from(nonce),
			counter: startCounter,
			in: Array.from(ciphertextArray),
		},
	)

	return {
		proofJson: JSON.stringify(proof),
		plaintext: makeUintArray(
			publicSignals
				.slice(0, ZK_CIRCUIT_CHUNK_SIZE)
				.map((x) => +x)
		)
	}
}

/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 * 
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput 
 * @param zkey 
 */
export async function verifyProof(
	{ proofJson, plaintext }: Proof,
	{ ciphertext }: PublicInput,
	operator: ZKOperator
): Promise<void> {
	const ciphertextArray = normaliseCiphertextForZk(ciphertext)
	if(ciphertextArray.length !== plaintext.length) {
		throw new Error(`ciphertext and plaintext must be the same length`)
	}
	// serialise to array of numbers for the ZK circuit
	const pubInputs = getSerialisedPublicInputs(
		{
			ciphertext: ciphertextArray,
			decryptedRedactedCiphertext: plaintext
		},
	)
	const verified = await operator.groth16Verify(
		pubInputs,
		JSON.parse(proofJson),
	)

	if(!verified) {
		throw new Error('invalid proof')
	}
}

/**
 * Serialise public inputs to array of numbers for the ZK circuit
 * the format is spread (output, ciphertext, redactedPlaintext)
 * @param inp 
 */
function getSerialisedPublicInputs(
	{ decryptedRedactedCiphertext, ciphertext }: {
		decryptedRedactedCiphertext: UintArray
		ciphertext: UintArray
	}
) {
	return [
		...Array.from(decryptedRedactedCiphertext),
		...Array.from(ciphertext),
	]
}

function normaliseCiphertextForZk(ciphertext: Uint8Array): UintArray {
	const ciphertextArray = padArray(
		toUintArray(padU8ToU32Array(ciphertext)),
		ZK_CIRCUIT_CHUNK_SIZE
	)

	if(ciphertextArray.length !== ZK_CIRCUIT_CHUNK_SIZE) {
		throw new Error(`ciphertext must be ${ZK_CIRCUIT_CHUNK_SIZE} words`)
	}

	return ciphertextArray
}
